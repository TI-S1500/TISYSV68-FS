


SH(1)							    SH(1)

NAME
     sh - Invokes the Bourne shell command interpreter

SYNOPSIS
     sh -acefhiknrstuvx [ args ]

DESCRIPTION
     The sh language is a command programming language that
     executes commands read from a terminal or a file.	See
     Invocation that follows for the meaning of arguments to the
     shell.

   Definitions
     A blank is a tab or a space.  A name is a sequence of
     letters, digits, or underscores beginning with a letter or
     underscore. A parameter is a name, a digit, or any of the
     characters *, @, #, ?, -, $, and !.

   Commands
     A simple-command is a sequence of non-blank words separated
     by blanks.  The first word specifies the name of the command
     to be executed.  Except as specified in the following text,
     the remaining words are passed as arguments to the invoked
     command.  The command name is passed as argument 0 (see
     exec(2)).	The value of a simple-command is its exit status
     if it terminates normally, or (octal) 200+status if it
     terminates abnormally (see signal(2) for a list of status
     values).

     A pipeline is a sequence of one or more commands separated
     by | (or, for historical compatibility, by ^).  The standard
     output of each command but the last is connected by a
     pipe(2) to the standard input of the next command.  Each
     command is run as a separate process; the shell waits for
     the last command to terminate.  The exit status of a
     pipeline is the exit status of the last command.

     A list is a sequence of one or more pipelines separated by
     ;, &, &&, or ||, and optionally terminated by ; or &.  Of
     these four symbols, ; and & have equal precedence, which is
     lower than that of && and ||.  The symbols && and || also
     have equal precedence.  A semicolon (;) causes sequential
     execution of the preceding pipeline; an ampersand (&) causes
     asynchronous execution of the preceding pipeline (i.e., the
     shell does not wait for that pipeline to finish).	The
     symbol && (||) causes the list following it to be executed
     only if the preceding pipeline returns a 0 (nonzero) exit
     status.  An arbitrary number of newlines may appear in a
     list, instead of semicolons, to delimit commands.

     A command is either a simple-command or one of the
     following.  Unless otherwise stated, the value returned by a
     command is that of the last simple-command executed in the
     command.

     for name  in word ...  do list done
	  Each time a for command is executed, name is set to the
	  next word taken from the in word list.  If in word ...
	  is omitted, the for command executes the do list once
	  for each positional parameter that is set (see
	  Parameter Substitution that follows).  Execution ends
	  when there are no more words in the list.

     case word in  pattern  | pattern  ... ) list ;;  ... esac
	  A case command executes the list associated with the
	  first pattern that matches word.  The form of the
	  patterns is the same as that used for file-name
	  generation (see File Name Generation that follows)
	  except that a slash, a leading dot, or a dot
	  immediately following a slash need not be matched
	  explicitly.  The esac statement ends the case command.

     if list then list	elif list then list  ...  else list  fi
	  The list following if is executed and, if it returns a
	  0 exit status, the list following the first then is
	  executed.  Otherwise, the list following elif is
	  executed and, if its value is 0, the list following the
	  next then is executed.  Failing that, the else list is
	  executed.  If no else list or then list is executed,
	  the if command returns a 0 exit status.  The fi
	  statement ends the if command.

     while list do list done
	  A while command repeatedly executes the while list and,
	  if the exit status of the last command in the list is
	  0, executes the do list; otherwise, the loop
	  terminates.  If no commands in the do list are
	  executed, the while command returns a 0 exit status;
	  until can be used in place of while to negate the loop
	  termination test.

     (list)
	  Executes list in a sub-shell.

     {list;}
	  list is simply executed.

     name () {list;}
	  Defines a function that is referenced by name. The body
	  of the function is the list of commands between { and
	  }.  Execution of functions is described in the
	  following text (see Execution).

     The following words are only recognized as the first word of
     a command and when not quoted:

       if then else elif fi case esac for while until do done { }

   Comments
     A word beginning with # causes that word and all the
     following characters up to a newline to be ignored.

   Command Substitution
     The standard output from a command enclosed in a pair of
     grave accents (` `) can be used as part or all of a word.
     Trailing newlines are removed.

     No interpretation is done on the string before the string is
     read, except to remove backslashes (\) used to escape other
     characters. Backslashes can be used to escape a grave accent
     (`) or another backslash (\) and are removed before the
     command string is read. Escaping grave accents allows nested
     command substitution. If the command substitution lies
     within a pair of double quotes ("...`...`..."), a backslash
     used to escape a double quote (\") will be removed;
     otherwise, it will be left intact.

     If a backslash is used to escape a new-line character
     (\new-line), both the backslash and the new-line character
     are removed (see the later section on Quoting). In addition,
     backslashes used to escape dollar signs (\$) are removed.
     Since no interpretation is done on the command string before
     it is read, inserting a backslash to escape a dollar sign
     has no effect.  Backslashes that precede characters other
     than \, `, ", new-line, and $ are left intact when the
     command string is read.

   Parameter Substitution
     The character $ is used to introduce substitutable
     parameters.  There are two types of parameters, positional
     and keyword.  If parameter is a digit, it is a positional
     parameter.  positional parameters may be assigned values by
     set.  Keyword parameters (also known as variables) may be
     assigned values by writing:

	  name=value

	  name=value
	   ...

     Pattern-matching is not performed on value.  There cannot be
     a function and a variable with the same name.

     ${parameter}
	  The value, if any, of the parameter is substituted.
	  The braces are required only when parameter is followed
	  by a letter, digit, or underscore that is not to be
	  interpreted as part of its name.  If parameter is * or
	  @, all the positional parameters, starting with $1, are
	  substituted (separated by spaces).  Parameter $0 is set
	  from argument zero when the shell is invoked.

     ${parameter:-word}
	  If parameter is set and is non-null, substitute its
	  value; otherwise, substitute word.

     ${parameter:=word}
	  If parameter is not set or is null, set it to word; the
	  value of the parameter is substituted.  Positional
	  parameters cannot be assigned to in this way.

     ${parameter:?word}
	  If parameter is set and is non-null, substitute its
	  value; otherwise, print word and exit from the shell.
	  If word is omitted, the message ``parameter null or not
	  set'' is printed.

     ${parameter:+word}
	  If parameter is set and is non-null, substitute word;
	  otherwise, substitute nothing.

     In the above, word is not evaluated unless it is to be used
     as the substituted string, so that, in the following
     example, pwd is executed only if the variable "d" is not set
     or is null:

	  echo ${d:-`pwd`}

     If the colon (:) is omitted from the preceding expressions,
     the shell only checks whether parameter is set.

     The following parameters are automatically set by the shell:

	  #    The number of positional parameters in decimal.
	  -    Flags supplied to the shell on invocation or by
	       the set command.
	  ?    The decimal value returned by the last
	       synchronously executed command.
	  $    The process number of this shell.
	  !    The process number of the last background command
	       invoked.

     The following parameters are used by the shell:

	  CDPATH
	       The search path for the cd command.

	  IFS  Internal field separators, normally space, tab,
	       and newline.

	  HOME
	       The default argument (home directory) for the cd
	       command.

	  MAIL
	       If this parameter is set to the name of a mail
	       file and the MAILPATH parameter is not set, the
	       shell informs the user of the arrival of mail in
	       the specified file.

	  MAILCHECK
	       This parameter specifies how often (in seconds)
	       the shell will check for the arrival of mail in
	       the files specified by the MAILPATH or MAIL
	       parameters.  The default value is 600 seconds (10
	       minutes).  If set to 0, the shell will check
	       before each prompt.

	  MAILPATH
	       A colon (:) separated list of file names.  If this
	       parameter is set, the shell informs the user of
	       the arrival of mail in any of the specified files.
	       Each file name can be followed by % and a message
	       that will be printed when the modification time
	       changes.  The default message is you have mail.

	  PATH
	       The search path for commands (see Execution that
	       follows).  The user cannot change PATH if
	       executing under rsh(1), the restricted Bourne
	       shell.

	  PS1  Primary prompt string, by default ``$ ''.

	  PS2  Secondary prompt string, by default ``> ''.

	  SHACCT
	       If this parameter is set to the name of a file
	       writable by the user, the shell will write an
	       accounting record in the file for each shell
	       procedure executed.  Accounting routines such as
	       acctcom(1) and acctcms (see acct(1M) for acctcms
	       description) can be used to analyze the data
	       collected.

	  SHELL
	       When the shell is invoked, it scans the
	       environment (see Environment that follows) for
	       this name.  If it is found and `rsh' is the file
	       name part of its value, the shell becomes a
	       restricted shell.

     The shell gives default values to PATH, PS1, PS2, MAILCHECK
     and IFS.  HOME and MAIL are set by login(1).

   Blank Interpretation
     After parameter and command substitution, the results of
     substitution are scanned for internal field separator
     characters (those found in IFS) and split into distinct
     arguments where such characters are found.  Explicit null
     arguments ("" or `') are retained.  Implicit null arguments
     (those resulting from parameters that have no values) are
     removed.

   File Name Generation
     Following substitution, each command word is scanned for the
     characters *, ?, and [.  If one of these characters appears,
     the word is regarded as a pattern.  The word is replaced
     with alphabetically sorted file names that match the
     pattern.  If no file name is found that matches the pattern,
     the word is left unchanged.  The character . at the start of
     a file name or immediately following a /, as well as the
     character / itself, must be matched explicitly.

	  *	 Matches any string, including the null string.
	  ?	 Matches any single character.
	  [...]  Matches any one of the enclosed characters.  A
		 pair of characters separated by - matches any
		 character lexically between the pair, inclusive.
		 If the first character following the opening
		 ``['' is a ``!'' any character not enclosed is
		 matched.

   Quoting
     The following characters have a special meaning to the shell
     and cause termination of a word unless quoted:

	  ;  &	(  )  |  ^ <  >  newline  space  tab

     A character can be quoted (i.e., made to stand for itself)
     by preceding it with a \ or inserting it between a pair of
     quote marks ('' or ""). During processing, the shell may
     quote certain characters to prevent them from taking on a
     special meaning. Backslashes used to quote a single
     character are removed from the word before the command is
     executed. The pair \new-line is removed from a word before
     command and parameter substitution.

     All characters enclosed between a pair of single quote marks
     (`), except a single quote, are quoted by the shell.
     Backslash has no special meaning inside a pair of single
     quotes. A single quote can be quoted inside a pair of double
     quote marks (for example, "'").

     Inside a pair of double quote marks (""), parameter and
     command substitution occurs and the shell quotes the results
     to avoid blank interpretation and file name generation. If
     $* is within a pair of double quotes, the positional
     parameters are substituted and quoted, separated by quoted
     spaces ("$1 $2 ..."); however, if $@ is within a pair of
     double quotes, the positional parameters are substituted and
     quoted, separated by unquoted spaces ("$1" "$2" ...). \
     quotes the characters \, `, ", and $. The pair \new-line is
     removed before parameter and command substitution. If a
     backslash precedes characters other than \, `, ", $, and
     new-line, the backslash itself is quoted by the shell.

   Prompting
     When used interactively, the shell prompts with the value of
     PS1 before reading a command.  If at any time a newline is
     typed and further input is needed to complete a command, the
     secondary prompt (i.e., the value of PS2) is issued.

   Input/Output
     Before a command is executed, its input and output can be
     redirected using a special notation interpreted by the
     shell.  The following can appear anywhere in a simple-
     command or can precede or follow a command and are not
     passed on as arguments to the invoked command.  Note that
     parameter and command substitution occurs before word or
     digit is used:

     <word	   Use file word as standard input (file
		   descriptor 0).

     >word	   Use file word as standard output (file
		   descriptor 1).  If the file does not exist it
		   is created; otherwise, it is truncated to zero
		   length.

     >>word	   Use file word as standard output.  If the file
		   exists, output is appended to it (by first
		   seeking to the end-of-file); otherwise, the
		   file is created.

     <<[-]word	   After parameter and command substitution is
		   done on word, the shell input is read up to
		   the first line that literally matches the
		   resulting word, or to an end-of-file. If,
		   however, - is appended to <<:

		   1. Leading tabs are stripped from word before the
		      shell input is read (but after parameter and
		      command substitution is done on word)
		   2. Leading tabs are stripped from the shell input
		      as it is read and before each line is compared
		      with word
		   3. Shell input is read up to the first line that
		      literally matches the resulting word, or to an
		      end-of-file.

		   If any character of word is quoted (see Quoting in
		   the preceding text), no additional processing is
		   done to the shell input. If no character of word
		   are quoted:

		   1. Parameter and command substitution occurs
		   2. (escaped) \new-line is ignored
		   3. \ must be used to quote the characters \, $,
		      and `.

		   The resulting document becomes the standard input.

     <&digit	   Use the file associated with file descriptor
		   digit as standard input.  Similarly for the
		   standard output using >&digit.

     <&-	   The standard input is closed.  Similarly for
		   the standard output using >&-.

     If any of the preceding items is prefixed by a digit, the
     file descriptor that will be associated with the file is
     that specified by the digit (instead of the default 0 or 1).
     For example:

	  ... 2>&1

     associates file descriptor 2 with the file currently
     associated with file descriptor 1.

     The order in which redirections are specified is
     significant.  The shell evaluates redirections left-to-
     right.  For example:

	  ... 1>xxx 2>&1

     first associates file descriptor 1 with file xxx.	It
     associates file descriptor 2 with the file associated with
     file descriptor 1 (i.e., xxx).  If the order of redirections
     were reversed, file descriptor 2 would be associated with
     the terminal (assuming file descriptor 1 had been) and file
     descriptor 1 would be associated with file xxx.

     Using the terminology introduced on the first page, under
     Commands, if a command is composed of several simple
     commands, redirection will be evaluated for the entire
     command before it is evaluated for each simple command. That
     is, the shell evaluates redirection for the entire list,
     each pipeline within the list, each command within each
     pipeline, and then each list within each command.

     If a command is followed by & the default standard input for
     the command is the empty file /dev/null. Otherwise, the
     environment for the execution of a command contains the file
     descriptors of the invoking shell as modified by
     input/output specifications.

     Redirection of output is not allowed in the restricted
     shell.

   Environment
     The environment (see environ(5)) is a list of name-value
     pairs that is passed to an executed program in the same way
     as a normal argument list.  The shell interacts with the
     environment in several ways.  On invocation, the shell scans
     the environment and creates a parameter for each name found,
     giving it the corresponding value.  If the user modifies the
     value of any of these parameters or creates new parameters,
     none of these affects the environment unless the export
     command is used to bind the shell's parameter to the
     environment (see also set -a).  A parameter can be removed
     from the environment with the unset command.  The
     environment seen by any executed command is thus composed of
     any unmodified name-value pairs originally inherited by the
     shell, minus any pairs removed by unset, plus any
     modifications or additions, all of which must be noted in
     export commands.

     The environment for any simple-command can be augmented by
     prefixing it with one or more assignments to parameters.
     Thus:

	  TERM=ansi cmd
	  and
	  (export TERM; TERM=ansi; cmd)

     are equivalent (as far as the execution of cmd is
     concerned).

     If the -k flag is set, all keyword arguments are placed in
     the environment, even if they occur after the command name.
     The following first prints a=b c and c:

	  echo a=b c
	  set -k
	  echo a=b c

   Signals
     The INTERRUPT and QUIT signals for an invoked command are
     ignored if the command is followed by &; otherwise, signals
     have the values inherited by the shell from its parent, with
     the exception of signal 11 (but see also the trap command
     that follows).

   Execution
     Each time a command is executed, the preceding substitutions
     are carried out.  If the command name matches one of the
     special commands listed in the following text, it is
     executed in the shell process.  If the command name does not
     match a special command, but matches the name of a defined
     function, the function is executed in the shell process
     (note how this differs from the execution of shell
     procedures).  The positional parameters $1, $2, ....  are
     set to the arguments of the function.  If the command name
     matches neither a special command nor the name of a defined
     function, a new process is created and an attempt is made to
     execute the command via exec(2).

     The shell parameter PATH defines the search path for the
     directory containing the command.	Alternative directory
     names are separated by a colon (:).  The default path is
     :/bin:/usr/bin (specifying the current directory, /bin , and
     /usr/bin, in that order).	Note that the current directory
     is specified by a null path name, which can appear
     immediately after the equal sign or between the colon
     delimiters anywhere else in the path list.  If the command
     name contains a /, the search path is not used; such
     commands will not be executed by the restricted shell.
     Otherwise, each directory in the path is searched for an
     executable file.  If the file has execute permission but is
     not an a.out file, it is assumed to be a file containing
     shell commands.  A sub-shell is spawned to read it.  A
     parenthesized command is also executed in a sub-shell.

     The location in the search path where a command was found is
     remembered by the shell (to help avoid unnecessary exec
     calls later).  If the command was found in a relative
     directory, its location must be re-determined whenever the
     current directory changes.  The shell forgets all remembered
     locations whenever the PATH variable is changed or the hash
     -r command is executed (see the following text).

   Special Commands
     Input/output redirection is now permitted for these
     commands.	File descriptor 1 is the default output location.

     :	  No effect; the command does nothing.	A zero exit code
	  is returned.

     . file
	  Read and execute commands from file and return.  The
	  search path specified by PATH is used to find the
	  directory containing file.

     break  n
	  Exit from the enclosing for or while loop, if any.  If
	  n is specified, break n levels.

     continue  n
	  Resume the next iteration of the enclosing for or while
	  loop.  If n is specified, resume at the nth enclosing
	  loop.

     cd  arg
	  Change the current directory to arg.	The shell
	  parameter HOME is the default arg.  The shell parameter
	  CDPATH defines the search path for the directory
	  containing arg.  Alternative directory names are
	  separated by a colon (:).  The default path is <null>
	  (specifying the current directory).  Note that the
	  current directory is specified by a null path name,
	  which can appear immediately after the equal sign or
	  between the colon delimiters anywhere else in the path
	  list.  If arg begins with a /, the search path is not
	  used.  Otherwise, each directory in the path is
	  searched for arg.  The cd command cannot be executed by
	  rsh.

     echo  arg ...
	  Echo arguments. See echo(1) for usage and description.

     eval  arg ...
	  The arguments are read as input to the shell and the
	  resulting command(s) executed.

     exec  arg ...
	  The command specified by the arguments is executed in
	  place of this shell without creating a new process.
	  Input/output arguments may appear and, if no other
	  arguments are given, cause the shell input/output to be
	  modified.

     exit  n
	  Causes a shell to exit with the exit status specified
	  by n.  If n is omitted the exit status is that of the
	  last command executed (an end-of-file will also cause
	  the shell to exit.)

     export [ name ...]
	  The given names are marked for automatic export to the
	  environment of subsequently executed commands.  If no
	  arguments are given, variable names that have been
	  marked for export during the current shell's execution
	  are listed. (Variable names exported from a parent
	  shell are listed only if they have been exported again
	  during the current shell's execution.)  Function names
	  are not exported.

     getopts
	  Use in shell scripts to support command syntax
	  standards; it parses positional parameters and checks
	  for legal options. See getopts(1) for usage and
	  description.

     hash [-r ][ name ...]
	  For each name, the location in the search path of the
	  command specified by name is determined and remembered
	  by the shell.  The -r option causes the shell to forget
	  all remembered locations.  If no arguments are given,
	  information about remembered commands is presented.
	  Hits is the number of times a command has been invoked
	  by the shell process.  Cost is a measure of the work
	  required to locate a command in the search path.  If a
	  command is found in a relative directory in the search
	  path, after changing to that directory, the stored
	  location of that command is recalculated.  Commands for
	  which this will be done are indicated by an asterisk
	  (*) adjacent to the hits information.  Cost will be
	  incremented when the recalculation is done.

     newgrp  arg ...
	  Equivalent to exec newgrp arg ....  See newgrp(1) for
	  usage and description.

     pwd  Print the current working directory.	See pwd(1) for
	  usage and description.

     read [ name ... ]
	  One line is read from the standard input and, using the
	  internal field separator, IFS (normally space or tab),
	  to delimit word boundaries, the first word is assigned
	  to the first name, the second word to the second name,
	  etc., with leftover words assigned to the last name.
	  Lines can be continued using \ new-line. Characters
	  other than new-line can be quoted by preceding them
	  with a backslash. These backslashes are removed before
	  words are assigned to names, and no interpretation is
	  done on the character that follows the backslash.  The
	  return code is 0 unless an end-of-file is encountered.

     readonly  name ...
	  The given names are marked readonly and the values of
	  the these names may not be changed by subsequent
	  assignment.  If no arguments are given, a list of all
	  readonly names is printed.

     return  n
	  Causes a function to exit with the return value
	  specified by n.  If n is omitted, the return status is
	  that of the last command executed.

     set  --aefhkntuvx	arg ...
	  -a   Marks variables that are modified or created for
	       export.
	  -e   Exits immediately if a command exits with a
	       nonzero exit status.
	  -f   Disables file name generation
	  -h   Locates and remembers function commands as
	       functions are defined (function commands are
	       normally located when the function is executed).
	  -k   Indicates that all keyword arguments are placed in
	       the environment for a command, not just those that
	       precede the command name.
	  -n   Reads commands but does not execute them.
	  -t   Exits after reading and executing one command.
	  -u   Treats unset variables as an error when
	       substituting.
	  -v   Prints shell input lines as they are read.
	  -x   Prints commands and their arguments as they are
	       executed.
	  --   Does not change any of the flags; useful in
	       setting $1 to -.
	  Using + rather than - causes these flags to be turned
	  off.	These flags can also be used upon invocation of
	  the shell.  The current set of flags can be found in
	  $-.  The remaining arguments are positional parameters
	  and are assigned, in order, to $1, $2, ....  If no
	  arguments are given the values of all names are
	  printed.

     shift  n
	  The positional parameters from $n+1 ...  are renamed $1
	  ....	If n is not given, it is assumed to be 1.

     test
	  Evaluate conditional expressions. See test(1) for usage
	  and description.

     times
	  Print the accumulated user and system times for
	  processes run from the shell.

     trap  arg	 n  ...
	  The command arg is to be read and executed when the
	  shell receives signal(s) n.  (Note that arg is scanned
	  once when the trap is set and once when the trap is
	  taken.)  Trap commands are executed in order of signal
	  number.  Any attempt to set a trap on a signal that was
	  ignored on entry to the current shell is ineffective.
	  An attempt to trap on signal 11 (memory fault) produces
	  an error.  If arg is absent all trap(s) n are reset to
	  their original values.  If arg is the null string, this
	  signal is ignored by the shell and by the commands it
	  invokes.  If n is 0 the command arg is executed on exit
	  from the shell.  The trap command with no arguments
	  prints a list of commands associated with each signal
	  number.

     type  name ...
	  For each name, indicate how it would be interpreted if
	  used as a command name.

     ulimit [ n ]
	  Imposes a size limit of n blocks on files written by
	  the shell and its child processes (files of any size
	  may be read).  If n is omitted, the current limit is
	  printed. You can lower your own ulimit, but only a
	  super-user (see su(1M) can raise a ulimit.

     umask  nnn
	  The user file-creation mask is set to nnn (see
	  umask(2)).  If nnn is omitted, the current value of the
	  mask is printed.

     unset  name ...
	  For each name, remove the corresponding variable or
	  function.  The variables PATH, PS1, PS2, MAILCHECK, and
	  IFS cannot be unset.

     wait  n
	  Wait for the specified process and report its
	  termination status.  If n is not given, all currently
	  active child processes are waited for and the return
	  code is 0.

   Invocation
     If the shell is invoked through exec(2) and the first
     character of argument zero is -, commands are initially read
     from /etc/profile and from $HOME/.profile, if such files
     exist.  Thereafter, commands are read as described in the
     following text, which is also the case when the shell is
     invoked as /bin/sh.  The flags that follow are interpreted
     by the shell on invocation only.  Unless the -c or -s flag
     is specified, the first argument is assumed to be the name
     of a file containing commands, and the remaining arguments
     are passed as positional parameters to that command file:

     -c string	If the -c flag is present commands are read from
		string.

     -s 	If the -s flag is present or if no arguments
		remain commands are read from the standard input.
		Any remaining arguments specify the positional
		parameters.  Shell output (except for special
		commands) is written to file descriptor 2.

     -i 	If the -i flag is present or if the shell input
		and output are attached to a terminal, this shell
		is interactive.  In this case TERMINATE is
		ignored (so that kill 0 does not kill an
		interactive shell) and INTERRUPT is caught and
		ignored (so that wait is interruptible).  In all
		cases, QUIT is ignored by the shell.

     -r 	If the -r flag is present the shell is a
		restricted shell.

     The remaining flags and arguments are described under the
     set command in the preceding text.

PROMPTS
   Input File Name:
     Enter the name of the file from which to execute commands.

   Accept Default Options:
     The initial value is yes.	Enter no to receive the following
     prompts.

   Exit on Abnormal Termination:
     The initial value is no.  Enter yes to exit the shell
     immediately if a command exits with a nonzero exit status.

   Keywords go into Environment:
     The initial value is no.  Enter yes to place all keywords
     into the environment.

   Parse Commands:
     The initial value is no.  Enter yes to read and not execute
     commands.

   Read/Execute One Command:
     The initial value is no.  Enter yes to exit the shell after
     reading and executing one command.

   Variable Substitution Error:
     The initial value is no.  Enter yes to treat unset variables
     as an error when substituting.

   Set Verbose Variable:
     The initial value is no.  Enter yes to print shell input
     lines as the shell reads them.

   Set Echo Variable:
     The initial value is no.  Enter yes to print commands and
     their arguments as the shell executes them.

   Restricted Shell:
     The initial value is no.  Enter yes to disallow the
     following:  changing the directory, setting the value of
     $PATH, specifying path or command names containing \, and
     redirecting output with > and >>.

FILES
     /etc/profile
     $HOME/.profile
     /tmp/sh*
     /dev/null

SEE ALSO
     a.out(4), acctcom(1), bsh(1), cd(1), csh(1), dup(2),
     echo(1), env(1), environ(5) exec(2), fork(2), getopts(1),
     login(1), newgrp(1), pipe(2), profile(4), pwd(1), signal(2),
     test(1), ulimit(2), umask(1), umask(2), wait(2).

NOTES
     If a command is executed, and a command with the same name
     is installed in a directory in the search path before the
     directory where the original command was found, the shell
     will continue to run the exec call on the original command.
     Use the hash command to correct this situation.

     If you move the current directory or one above it, pwd may
     not give the correct response.  Use the cd command with a
     full path name to correct this situation.

     Not all the processes of a 3- or more-stage pipeline are
     children of the shell, and thus cannot be waited for.

     For wait n, if n is not an active process ID, all your
     shell's currently active background processes are waited for
     and the return code will be 0.

CAVEATS
     Words used for file names in input/output redirection are
     not interpreted for file name generation (see File Name
     Generation in the preceding text). For example, cat file1
     >a* will create a file named a*.

     Because commands in pipelines are run as separate processes,
     variables set in a pipeline have no effect on the parent
     shell.

     If you get the error message cannot fork, too many
     processes, try using the wait(1) command to clean up your
     background processes.  If this does not help, the system
     process table is probably full or you have too many active
     foreground processes. (There is a limit to the number of
     process IDs associated with your login and to the number the
     system can keep track of.)
