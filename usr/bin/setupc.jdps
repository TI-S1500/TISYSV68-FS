:
# SETUPC.mkm 04/08/96, Martin Meier, JDIS Research
# this script assumes calls to UNIX will be made from bourne shell "sh"
# revised 05/29/96 M.K. Meier
# revised work-around /etc/mkalp for HP systems where version problems exist

#----PROCEDURE: remove_oldport() removes previous PS port ----------------#
remove_oldport() {

target_file='/JDIS/PROG/CMN/PSPORT'
clear_screen

echo "
                        Remove Old PS Port
 ___________________________________________________________________________

  This program provides the facility to remove an existing PS Port.  This
  facility is useful where the PS Port is required to move from a non-modem
  control port such as a MUX connection to a full modem control port such
  as on the MDP or in the case of completely removing a PS Port.

  If requested, this procedure should be completed before the addition of a
  new PS Port to ensure efficient PS program and file management.

 ___________________________________________________________________________

 Do you wish to remove an existing PS Port?   Y\N > \c"
read ans

case $ans in
  Y|y ) clear_screen
        echo "
Remove Old PS Port:          Existing PS Ports
___________________________________________________________________________

`cat "$target_file"`

___________________________________________________________________________

               Enter 2 digit port number to remove

               or press <enter> if no port removal

               is requested.

___________________________________________________________________________

               Enter your choice > \c"
               read port

if [ -z "$port" ]
 then
 leave_prg
fi

if grep "$port" $target_file > /dev/null
 then
  #remove the PSPORT entry #

    remove_ln=`grep "$port" $target_file`
    sed "/$remove_ln/d" $target_file > $target_file.tmp
    cp $target_file.tmp $target_file && rm -f $target_file.tmp

  #find the associated printer and remove it:use procedure conv_hexlp#

    conv_hexlp
    echo "\n Found $oldlp:  Removing $oldlp"
    sleep 2

  if `lpstat -s | grep $oldlp > /dev/null`
   then
  /usr/lib/lpshut
  /usr/lib/lpadmin -x$oldlp
  /usr/lib/lpsched
  fi
  remove_status="been successfully"

 else
  remove_status="not been"
  echo "
  ERROR: $port does not exist in $target_file.

 ___________________________________________________________________________

   After this screen clears, please recheck your port choice
   and rerun PS Port Remove program option.

 ___________________________________________________________________________

  Press <enter> to continue \c"
  read ans

 fi

               clear_screen
               echo "

 PS PORT $port has $remove_status removed.
 ___________________________________________________________________________


 You may proceed from this point to add a PS PORT.

 ___________________________________________________________________________

 Do you wish to continue with PS PORT addition ?  Y\N > \c"

read ans

 case $ans in
  Y|y ) continue   ;;

  N|n ) leave_prg  ;;

    * ) leave_prg  ;;
 esac
 ;;


  N|n ) continue        ;;

    * ) continue        ;;

esac
}
#-------------------------------------------------------------------------#

#----PROCEDURE: get_port() gets port assignment from user ----------------#
get_port() {

#-- procedure: port_valid1() ---------------------------------------------#
port_valid1() {
echo "\007\n
 Entry not valid: $port ... acceptable range: 01-5a, 92-96
\npress <enter> to retry\c"
 read ans
 port_valid=1
}
#-------------------------------------------------------------------------#

#-- procedure: port_valid0() ---------------------------------------------#
port_valid0() {
 echo "
 ___________________________________________________________________________
    The port entered was $port.
   \n OK to proceed?  Y, N or <enter> to END > \c"
   read ans
    case $ans in
            Y | y ) port_valid=0
                    tty_id="/dev/tty$port"
                    tty_base="tty$port"                                  ;;
            N | n ) port_valid=1                                         ;;
            *     ) leave_prg                                            ;;
    esac
}
#-------------------------------------------------------------------------#

port_valid="1"
until [ "$port_valid" -eq 0 ]
do
clear_screen
echo "
                       Personal Service Port Setup
 ___________________________________________________________________________


 Designate 2 digit tty port assignment, logical range= 01 - 5a, 92-96

 example: type \"09\" for tty09
 \n

 ___________________________________________________________________________

 Enter port assignment or press <enter> to quit: > \c"

read port
if [ -z "$port" ] #checks for null entry and exits
 then
  leave_prg
 elif [ `echo "$port" | wc -c` -lt 3 ]
  then
   echo "\007
 ERROR: port entry must be 2 digits: $port was entered
\n press <enter> to continue"
  read ans
  port_valid=1
fi

case $port in
 0              ) port_valid1                   ;;
 [0][0]         ) port_valid1                   ;;
 [0-5][0-9]     ) port_valid0                   ;;
 [9][2-6]       ) port_valid0                   ;;
 [0-5][a-f]     ) port_valid0                   ;;
 *              ) port_valid1                   ;;
esac

done
}
#-------------------------------------------------------------------------#

#----PROCEDURE: get_termtype() -------------------------------------------#
# determine tty type from user input
get_termtype() {

term_id1="TERMiTE Emulator"
term_id2="TI  924 Terminal"
term_id3="TI  928 Terminal"
type_valid=1

until [ "$type_valid" -eq 0 ]
do
clear_screen
echo "
 Choose number corresponding with terminal type from list below:
 ___________________________________________________________________________

                         1 - $term_id1

                         2 - $term_id2

                         3 - $term_id3

 __________________________________________________________________________

 Enter choice: 1,2,3 or <enter> to End  > \c"
read ttychoice
if [ -z "$ttychoice" ] #checks for null entry and exits
  then
   leave_prg
else
 case $ttychoice in
        1|2|3 ) echo "
 The number entered was $ttychoice.\n
 OK to proceed?  Y, N or <enter> to END > \c"
               read ans
                case $ans in
                      Y | y ) case $ttychoice in
                               1 ) mk_termid="TERMiTE Emulator" ;;
                               2 ) mk_termid="TI  924 Terminal" ;;
                               3 ) mk_termid="TI  928 Terminal" ;;
                              esac

                              case $ttychoice in
                                1) ttype=t1   ;;
                                2) ttype=t1   ;;
                                3) ttype=x1   ;;
                              esac

                              type_valid=0                               ;;

                      N | n ) type_valid=1                               ;;
                      *     ) leave_prg                                  ;;
                esac                                                     ;;

            0 ) leave_prg                                                ;;
            * ) leave_prg                                                ;;
 esac
fi
done
}
#-------------------------------------------------------------------------#

#----PROCEDURE: ck_port_use() --------------------------------------------#
ck_port_use() {
clear_screen
# determine is port is in use now #
if `who | grep $tty_base > /dev/null`
  then
echo "\007
                          >> ERROR <<
 __________________________________________________________________________

 Port $port, $tty_base, is in use by: `who | grep $tty_base`\n
 This is a serious error and should be investigated before restarting
 procedure.

 It is advisable to SCREEN PRINT this page for use in error resolution.
 After determining if port is correct, choose option SETUPC in Main Menu.

 Program will terminate...
 ___________________________________________________________________________

 press <enter> to continue \c"
read ans
leave_prg
fi
}
#-------------------------------------------------------------------------#

#----PROCEDURE: check_port() ---------------------------------------------#
# Check if device file for port/tty exists and is character device.
#
check_port() {

case $OS in

 HP )
# if an HP MDP device = 92 - 96, then remove device so it can be remade #

if [ "$port" -gt 91 -a "$port" -lt 97 ]
 then
rm -f $tty_id
rm_stmt="Device file $tty_id, has been removed by system and will be recreated
 by the system.  It is necessary to remove and recreate the device when
 connecting to the MDP type interface in order to ensure full modem control."

elif [ -c $tty_id ]
   then
    continue # don't remove mux port if exists
elif [ ! -c $tty_id ]
   then
     mknod $tty_id c 58 0x0001$port
     /bin/chmod 666 $tty_id
  fi
;;

 TI ) if [ ! -c $tty_id ]
       then
        no_ttydev=1
        no_tidevice
        leave_prg
      fi
 ;;
esac

if [ ! -c $tty_id ]
 then
  clear_screen
echo "\007
                            Device File Info
 ___________________________________________________________________________

 $tty_id does not exist in system.\n
 $rm_stmt\n
 This program will proceed to create proper device file.

 It is advisable to SCREEN PRINT this page for use in error resolution.
 Please determine from Dealer/Focus Person that port $tty_base is correct.
 If after determining to proceed with device file creation, press <return>
 as stated below to enter the Make Device procedure. If you do not wish to
 create a device file at this time, press <return> at the prompt below and
 choose option to End program on following screen.

 ___________________________________________________________________________
 "
 echo " Press <enter> to continue ...\c"
read ans
   dev_ok="N"
elif [ -c $tty_id ]
 then
   dev_ok="Y"
fi
}
#-------------------------------------------------------------------------#

#----PROCEDURE: make_device() --------------------------------------------#
make_device() {

clear_screen
case $dev_ok in

        N )  echo "
                    Device File Creation Procedure
 ___________________________________________________________________________

            Preparing to create device file: $tty_id


\n                     Do you wish to continue?

 ___________________________________________________________________________

 Enter your choice - Y, N, or <return> to End > \c"
read ans
    case $ans in
      Y|y ) continue                                                     ;;
      N|n ) leave_prg                                                    ;;
        * ) leave_prg                                                    ;;
    esac

              case $OS in
                HP ) case $port in
                       92 ) mknod $tty_id c 58 0x200002  ;;
                       93 ) mknod $tty_id c 58 0x200003  ;;
                       94 ) mknod $tty_id c 58 0x200004  ;;
                       95 ) mknod $tty_id c 58 0x200005  ;;
                       96 ) mknod $tty_id c 58 0x200006  ;;
                     esac                                       ;;

                TI ) echo "
ERROR: TI UNIX: device file $tty_id does not exist and cannot be created
 by this automated application. There may be a problem with the tty $tty_id
 or the device file has been removed in error prior to this application.
 Please consult your Systems Support Staff for assistance.
 Program will exit when <return> is pressed > \c"
 read ans
 leave_prg   ;;

      esac                                                               ;;

        Y ) continue                                                     ;;

esac

}
#-------------------------------------------------------------------------#

#----PROCEDURE: ck_majnum() ----------------------------------------------#
# HP  checks if port designate has major number of 58 for MDP or MUX
# TI  checks if port designate has major number of 5 for MTC
ck_majnum() {

if [ -c $tty_id ]
 then

case $OS in

 HP )  dev_maj=`ls -l $tty_id | awk -F" " '{print $5}'`
        if [ "$dev_maj" -ne 58 ]
         then
          clear_screen
          echo "\007
 This program cannot be run from terminal $tty_id. It is either
 a network device or is not a MUX / MDP device.

 It is advisable to SCREEN PRINT this page for use in error resolution.
 This program will terminate after this screen. Determine that the port
 to be configured is correct.Select a valid device and restart program.
 Device major number=$dev_maj, tty=$tty_id\c"
           read ans3
           exit 1
        fi                                                             ;;

 TI ) dev_maj=`ls -l $tty_id | awk -F" " '{print $5}' | sed 's/,.*//'`
       if [ "$dev_maj" -ne 5 ]
         then
          clear_screen
          echo "\007
 This program cannot be run from terminal $tty_id. It is either
 a network device or is not a MTC device.

 It is advisable to SCREEN PRINT this page for use in error resolution.
 This program will terminate after this screen. Determine that the port
 to be configured is correct.Select a valid device and restart program.
 Device major number=$dev_maj, tty=$tty_id\c"
         read ans
         exit 1
       fi                                                                ;;
esac
elif [ ! -c $tty_id ]
 then
  clear_screen
  echo "\007
 Device file $tty_id does not exist.  Possible cause for this error is
 due to incorrect userid status (root required) or system device conflict.
 This is a serious error and will terminate program.  Consult support
 staff for advice.\n
 Please SCREEN PRINT this page for use in error resolution.

 Press <enter> to continue. \c"
read ans
leave_prg
fi
}
#-------------------------------------------------------------------------#

#----PROCEDURE: display_entries() ----------------------------------------#
display_entries() {
clear_screen

echo "
 Personal Service Port to be configured on the following:
 ___________________________________________________________________________

                         tty port = $port

                    terminal type = $mk_termid

 ___________________________________________________________________________
"
echo " OK to proceed?  Y, N or <enter> to END > \c"
read ans
if [ -z "$ans" ] #checks for null entry and exits
 then
  leave_prg
fi
 case $ans in
      Y | y ) echo "\n ... working ... \c"                             ;;
      N | n ) clear_screen
              echo "
 The port and terminal type must be acceptable before continuing.
 All options must be reset and accepted. Program terminating ...
 Choose SETUPC from Main Menu to rerun program...\n
 Press <enter> when ready \c"
read ans
leave_prg                                                                ;;
       * ) echo "\n\007... unknown entry ... exiting" ; sleep 2
            leave_prg                                                    ;;
esac
}
#-------------------------------------------------------------------------#

#----PROCEDURE: do_setup() -----------------------------------------------#
do_setup() {

# remove and re-add /etc/inittab entry

case $OS in
  HP)
      ## check for next ps0-50 id for /etc/inittab line-identifier
          valid_tab=1 ; ps_tab=0
           until [ "$valid_tab" -eq 0 ]
            do
             if grep -q "ps$ps_tab" /etc/inittab
              then
               ps_tab=`expr $ps_tab + 1`
              else
               valid_tab=0
             fi
            done

     new_tab="ps$ps_tab:2:respawn:/etc/getty -h $tty_base 19200"

## make new inittab entry for /etc/inittab
# make copy of /etc/inittab
cp /etc/inittab /etc/inittab.ps

 if grep -q $tty_base /etc/inittab
  then
   cp /etc/inittab /etc/inittab.ps_save
    old_tab=`grep $tty_base /etc/inittab`
   sed "s!$old_tab!$new_tab!" /etc/inittab > /etc/tmp_pstab
   cp /etc/tmp_pstab /etc/inittab && rm -f /etc/tmp_pstab
   init q
   kill -9 `ps -ef|grep $tty_base|grep -v grep|awk '{print $2}'`
  else
   cp /etc/inittab /etc/inittab.ps_save
   echo "$new_tab" >> /etc/inittab
   init q
 fi

## make new inittab entry for /etc/inittab.on
# make copy of /etc/inittab.on
cp /etc/inittab.on /etc/inittab.on.ps

 if grep -q $tty_base /etc/inittab.on
  then
    old_tab=`grep $tty_base /etc/inittab.on`
   sed "s!$old_tab!$new_tab!" /etc/inittab.on > /etc/tmp_pstab.on
   cp /etc/tmp_pstab.on /etc/inittab.on && rm -f /etc/tmp_pstab.on
  else
   echo "$new_tab" >> /etc/inittab.on
 fi

## make new inittab entry for /etc/inittab.off
# make copy of /etc/inittab.off
cp /etc/inittab.off /etc/inittab.off.ps

 if grep -q $tty_base /etc/inittab.off
  then
   old_tab=`grep $tty_base /etc/inittab.off`
   sed "s!$old_tab!$new_tab!" /etc/inittab.off > /etc/tmp_pstab.off
   cp /etc/tmp_pstab.off /etc/inittab.off && rm -f /etc/tmp_pstab.off
  else
   echo "$new_tab" >> /etc/inittab.off
 fi

## adjust entries in /etc/ttytype for proper term type
# make copy of original /etc/ttytype file

ttyps_save='/etc/ttytype.ps'
cp /etc/ttytype $ttyps_save

new_ttype="$ttype $tty_base"

if grep -q $tty_base /etc/ttytype
  then
   old_ttype=`grep $tty_base /etc/ttytype`
   sed "/$tty_base/d" /etc/ttytype > /etc/tmp_ttytype
   cp /etc/tmp_ttytype /etc/ttytype && rm -f /etc/tmp_ttytype
   echo $new_ttype >> /etc/ttytype
  else
   echo $new_ttype >> /etc/ttytype
 fi

## create/update /JDIS/PROG/CMN/PSPORT with new valid tty entry

target_file='/JDIS/PROG/CMN/PSPORT'
if [ ! -f "$target_file" ]
 then
  touch $target_file
  echo "S AS DIALTERM1 $port" > $target_file
 elif grep -q "$port" $target_file
  then
   break
 elif test -f $target_file
  then
   num_lin=`wc -l $target_file | awk '{print $1}'`
   count=1
  until [ "$count" -gt `echo $num_lin` ]
   do
     test_pslin=`grep "S AS DIALTERM$count" $target_file`
      if [ `echo $test_pslin | awk '{print NF}'` -eq 3 ]
       then
        new_pslin="$test_pslin $port"
        sed "s/$test_pslin/$new_pslin/" $target_file > $target_file.tmp
        cp $target_file.tmp $target_file && rm -f $target_file.tmp
        break
       else
        count=`expr $count + 1`
      fi
    done
     if [ "$count" -gt `echo $num_lin` ]
      then
       new_pslin="S AS DIALTERM$count $port"
       echo $new_pslin >> $target_file
     fi
fi

## update /etc/alpcaps

tm_string='tm termite: bb=\E[5i eb=\E[4i pr=\\0 sz=132 rt=100'

case $ttychoice in
 1) if  grep -q  'tm termite' /etc/alpcaps
     then
      cp /etc/alpcaps /etc/alpcaps.ps_save
      sed '/tm termite/d' /etc/alpcaps > /etc/tmp_alpcaps
      cp /etc/tmp_alpcaps /etc/alpcaps && rm -f /etc/tmp_alpcaps
      echo $tm_string >> /etc/alpcaps
     else
      echo $tm_string >> /etc/alpcaps
    fi                                                                   ;;

 * ) :                                                                   ;;
esac

### create printer for tty, update /etc/alpdefs and alp device
## determine if tty92-96 or 01-91
# declare newlp_id and create newlp="lp$newlp_id"
# call procedure conv_hexlp

conv_hexlp

# # check for, remove and remake alp device

alp_dev="/dev/alp$port"
alp_id="alp$port"
cp /etc/alpdefs /etc/alpdefs.ps_save

if [ ! -c "$alp_dev" ]
 then
  continue
 elif [ -c "$alp_dev" ]
  then
  rm -f "$alp_dev"
fi

case $ttychoice in
 1) alp_string='alp_dev  bb=\E[5i eb=\E[4i pr=\\0 sz=132 rt=100'     ;;
 2) alp_string='alp_dev  bb=\E[5i eb=\E[?9i pr=\\EQ sz=132 rt=0'     ;;
 3) alp_string='alp_dev  bb=\E[5i eb=\E[?90i pr=\\EQ sz=132 rt=0'    ;;
esac

if grep -q "$alp_dev" /etc/alpdefs
 then
   sed "/$alp_id/d" /etc/alpdefs > /etc/alpdefs.ps_tmp
   cp /etc/alpdefs.ps_tmp /etc/alpdefs && rm -f /etc/alpdefs.ps_tmp
   echo "$alp_string" >> /etc/alpdefs
   sed "s!alp_dev!$alp_dev!" /etc/alpdefs > /etc/alpdefs.ps_tmp
   cp /etc/alpdefs.ps_tmp /etc/alpdefs && rm -f /etc/alpdefs.ps_tmp
  else
   echo "$alp_string" >> /etc/alpdefs
   sed "s!alp_dev!$alp_dev!" /etc/alpdefs > /etc/alpdefs.ps_tmp
   cp /etc/alpdefs.ps_tmp /etc/alpdefs && rm -f /etc/alpdefs.ps_tmp
fi

if [ "$port" -gt 91 -a "$port" -lt 97 ] ## MDP connections
 then
  end_digit=`echo "$port" | cut -c2`
  /etc/mknod $alp_dev c 58 0x21000$end_digit
  /bin/chown lp  $alp_dev
  /bin/chgrp bin $alp_dev
  /bin/chmod 666 $alp_dev
  /etc/initalp -d $alp_dev
else
   /etc/mknod $alp_dev c 58 0x0101$port
   /bin/chown lp  $alp_dev
   /bin/chgrp bin $alp_dev
   /bin/chmod 666 $alp_dev
   /etc/initalp -d $alp_dev
fi

# check for logical printer, see if busy, create if necessary

if `lpstat -s | grep -x -q "$newlp:"`
then
  continue
 else
  /usr/lib/lpshut > /dev/null
  /usr/lib/lpadmin -p$newlp -mstandard -v$alp_dev > /dev/null
  /usr/lib/accept $newlp > /dev/null
  /usr/bin/enable $newlp > /dev/null
  /usr/lib/lpsched > /dev/null
fi                                                                       ;;

###### TI ######

TI)

## check entry in inittab  ##
# step 1: make sure entry is in /etc/inittab so devadm can remove and readd

new_tab="t0$port:2:respawn:/etc/getty $tty_base R19200PS $ttype"

 if grep "$tty_base" /etc/inittab > /dev/null
  then
   continue
  else
   cp /etc/inittab /etc/inittab.ps_save
   echo "$new_tab" >> /etc/inittab
 fi

## create/update /JDIS/PROG/CMN/PSPORT with new valid tty entry

target_file='/JDIS/PROG/CMN/PSPORT'
if  [ ! -f "$target_file" ]
 then
  touch $target_file
  echo "S AS DIALTERM1 $port" > $target_file
 elif grep "$port" $target_file > /dev/null
  then
   break
 elif [ -f $target_file ]
  then
   num_lin=`wc -l $target_file | awk '{print $1}'`
   count=1
  until [ "$count" -gt `echo $num_lin` ]
   do
     test_pslin=`grep "S AS DIALTERM$count" $target_file`
      if [ `echo $test_pslin | awk '{print NF}'` -eq 3 ]
       then
        new_pslin="$test_pslin $port"
        sed "s/$test_pslin/$new_pslin/" $target_file > $target_file.tmp
        cp $target_file.tmp $target_file && rm -f $target_file.tmp
        break
       else
        count=`expr $count + 1`
      fi
    done
     if [ "$count" -gt `echo $num_lin` ]
      then
       new_pslin="S AS DIALTERM$count $port"
       echo $new_pslin >> $target_file
     fi
fi

## update /etc/alpcaps

tm_string='tm termite: bb=\E[5i eb=\E[4i pr=\\0 sz=132 rt=100'

case $ttychoice in
 1) if  grep 'tm termite' /etc/alpcaps > /dev/null
     then
      cp /etc/alpcaps /etc/alpcaps.ps_save
      sed '/tm termite/d' /etc/alpcaps > /etc/tmp_alpcaps
      cp /etc/tmp_alpcaps /etc/alpcaps && rm -f /etc/tmp_alpcaps
      echo $tm_string >> /etc/alpcaps
     else
      echo $tm_string >> /etc/alpcaps
    fi                                                                   ;;

 *) :                                                                    ;;
esac

### create printer for tty, update /etc/alpdefs and alp device
## determine if tty92-96 or 01-91
# declare newlp_id and create newlp="lp$newlp_id"
# call procedure conv_hexlp

conv_hexlp

#check for remove and remake alp device

alp_dev="/dev/alp$port"
alp_id="alp$port"

case $ttychoice in
 1) alp_term=tm ;;
 2) alp_term=t1 ;;
 3) alp_term=x1 ;;
esac

if [ ! -c $alp_dev ] ## double check for previous device missing
 then
  no_alpdev=1
  no_tidevice
  leave_prg
 elif [ -c $alp_dev ]
  then
   devadm -m tty $tty_base -p -t $alp_term
   /bin/chmod 666 $alp_dev
   /etc/initterm p
fi

## make new entry for /etc/inittab ##

new_tab="t0$port:2:respawn:/etc/getty $tty_base R19200PS $ttype"

 if grep "$tty_base" /etc/inittab > /dev/null
  then
   cp /etc/inittab /etc/inittab.ps_save
    old_tab=`grep $tty_base /etc/inittab`
   sed "s!$old_tab!$new_tab!" /etc/inittab > /etc/tmp_pstab
   cp /etc/tmp_pstab /etc/inittab && rm -f /etc/tmp_pstab
   init q
   kill -9 `ps -ef|grep $tty_base|grep -v grep|awk '{print $2}'`
  else
   cp /etc/inittab /etc/inittab.ps_save
   echo "$new_tab" >> /etc/inittab
   init q
 fi

# check for logical printer, see if busy, create if necessary

if `lpstat -s | fgrep -x "$newlp:" > /dev/null`
 then
  continue
 else
  /usr/lib/lpshut > /dev/null
  /usr/lib/lpadmin -p$newlp -mstandard -v$alp_dev > /dev/null
  /usr/lib/lpsched >/dev/null
  /usr/lib/accept $newlp > /dev/null
  /usr/bin/enable $newlp > /dev/null
fi

## add entry to /etc/gettydefs for TI Systems with PS specs #

if grep 'R19200PS' /etc/gettydefs > /dev/null
 then
  continue
 else
echo '
#-------------------------------------------------------------------#
#    Remote 19200 baud, 7 data bits, 1 stop bit, odd parity,        #
#    For Personal Services Logins.                                  #
#-------------------------------------------------------------------#

R19200PS #
EXTA HUPCL ECHO CS7 PARENB PARODD IXON #
EXTA HUPCL CREAD ICRNL IXON BRKINT OPOST ONLCR ICANON ECHO ECHOE ECHOK
     ISIG CS7 PARENB PARODD IXOFF TAB3 #
 JDPS login: #
R19200PS

' >> /etc/gettydefs
fi
#

## Add stty -clocal to PST1 or PSX1 to ensure process drop upon close

t1_profile='/JDIS/PROG/CMN/PST1'
t1_pftmp='/JDIS/PROG/CMN/PST1.tmp'
x1_profile='/JDIS/PROG/CMN/PSX1'
x1_pftmp='/JDIS/PROG/CMN/PSX1.tmp'

# check/change PST1

if fgrep -x 'stty -clocal' $t1_profile > /dev/null
 then
  continue
 else
  sed '/stty /a\
stty -clocal' $t1_profile > $t1_pftmp
cp $t1_pftmp $t1_profile && rm -f $t1_pftmp
fi

# check/change PSX1

if fgrep -x 'stty -clocal' $x1_profile > /dev/null
 then
  continue
 else
  sed '/stty /a\
stty -clocal' $x1_profile > $x1_pftmp
cp $x1_pftmp $x1_profile && rm -f $x1_pftmp
fi

;;
esac
}
#-------------------------------------------------------------------------#

#----PROCEDURE: conv_hexlp () convert tty from hex to printer name -------#
conv_hexlp() {

if [ "$port" -gt 91 -a "$port" -lt 97 ]
 then
 case $port in
      92 ) newlp="lpPA" ; oldlp="lpPA" ;;
      93 ) newlp="lpPB" ; oldlp="lpPB" ;;
      94 ) newlp="lpPC" ; oldlp="lpPC" ;;
      95 ) newlp="lpPD" ; oldlp="lpPD" ;;
      96 ) newlp="lpPE" ; oldlp="lpPE" ;;
  esac

else
# convert $port from hex to decimal, then add 2 to label new printer id

  if [ `echo $port | cut -c2 | grep '[a-f]'` ]
  then
     pos1=`echo $port | cut -c2 | tr '[a-f]' '[0-5]'`
     pos1=`expr $pos1 + 10`
      else
       pos1=`echo $port | cut -c2`
  fi

pos2=`echo $port | cut -c1 | tr '[a-f]' '[0-5]'`
pos2=`expr $pos2 \* 16 + $pos1`

## create newlp_id and newlp
newlp_id=`expr $pos2 + 2`

  if [ `echo "$newlp_id" | wc -c` -lt 3 ]
   then
    newlp_id="0$newlp_id"
  fi

   newlp="lp$newlp_id"
   oldlp="lp$newlp_id"

fi
}
#-------------------------------------------------------------------------#

#----PROCEDURE: show_status() --------------------------------------------#
show_status() {
:
}

#-------------------------------------------------------------------------#

#----PROCEDURE: no_tidevice() --------------------------------------------#
no_tidevice() {
if [ "$no_alpdev" -eq 1 ]
 then
echo '\007\007
 ERROR: alp device $alp_dev does not exist in this system and cannot be
        created.  This procedure will terminate after this screen. Please
        consult Technical Support for assistance.

 Press <enter> to continue ... \c'
read ans
elif [ "$no_ttydev" -eq 1 ]
 then
echo '\007\007
 ERROR: tty device $tty_id does not exist in this system and cannot be
        created.  This procedure will terminate after this screen. Please
        consult Technical Support for assistance.

 Press <enter> to continue ... \c'
read ans
fi
}
#-------------------------------------------------------------------------#

#----PROCEDURE: clear_screen() clears screen based upon platform type ----#
clear_screen() {
case $OS in
        HP)     clear           ;;
        TI)     tput clear      ;;
esac
}
#-------------------------------------------------------------------------#

#----PROCEDURE: leave_prg() ----------------------------------------------#
leave_prg() {
clear_screen
echo "\007
Exiting program ... user request\n"
sleep 2
exit 0
}
#-------------------------------------------------------------------------#

####  PROGRAM: SETUPC  ####################################################
#                                                                         #
# assign variables

OS=`uname -s | cut -c1-2`
#jdps_error='/tmp/jdps_setup_error'
#touch $jdps_error
# begin procedures

remove_oldport
get_port
get_termtype
ck_port_use
check_port
make_device
ck_majnum
display_entries
do_setup
#show_status

#                                                                         #
###########################################################################
